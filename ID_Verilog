/* Instruction Decode Module
	Below are all the modules for the instruction decode.
	At the top we have all those small modules connected and tested by the testbench all the way at the bottom of the file.
*/
module ID(
   input reg_write,
   [31:0] inst, w_data,
   [4:0] write_reg,
   output wire reg_write_out, alu_src, reg_dst, mem_read, mem_write, mem_to_reg, branch,
   [1:0] alu_op,
   [31:0] r_data_1, r_data_2, sign_ext_inst);
   wire [5:0] op;
   wire [4:0] rs, rt, rd;
   
   assign rs = inst[25:21];
   assign rt = inst[20:16];
   assign rd = write_reg;
   
   assign op = inst[31:26];
   
 
   register	REGS		(  	.WEn        	(reg_write),
                    		.Rs         	(rs),
                    		.Rt         	(rt),
                    		.Rd         	(rd),	// This is the input decided in the EX phase of the RegDst selected Mux
                    		.WData      	(w_data),
                    		.RData1     	(r_data_1),
                    		.RData2     	(r_data_2));
	
   SignExtend  SE  		(.in         	(inst[15:0]),
                    	 .out        	(sign_ext_inst));
                   	 
   MainControlUnit  MC (.op         	(op),
                    	.reg_write  	(reg_write_out),
                    	.alu_src    	(alu_src),
                    	.reg_dst    	(reg_dst),
                    	.mem_read   	(mem_read),
                    	.mem_write  	(mem_write),
                    	.mem_to_reg 	(mem_to_reg),
                    	.branch     	(branch),
                    	.alu_op     	(alu_op));
   	 
 
endmodule
/*  Register File
	Outputs read date on the WEn Logic High or Write's Data on WEn Logic Low
*/
module register(input WEn, [4:0]Rs, [4:0]Rt, [4:0]Rd, [31:0]WData, output [31:0]RData1, [31:0]RData2);
   reg [31:0] regs [31:0];
   reg [31:0] RD1, RD2 =0;
   assign RData1 = RD1;
   assign RData2 = RD2;
   always @(WEn or Rs or Rt)
   begin
   	if(!WEn)begin
           	RD1 <= regs[Rs];
           	RD2 <= regs[Rt];
   	end
   end
   always @(WEn or WData or Rd)
   begin
   	if(WEn)
       	regs[Rd] <= WData;
   end
endmodule
 
module SignExtend(
   input [15:0] in,
   output [31:0] out);
 
   assign out = {{16{in[15]}}, in};
endmodule

/*Control Unit which provides all signals to the different components in different stages 
 Which will provide different signals depedning on the opcode. 
 */
module MainControlUnit (
   input [5:0] op,
   output reg reg_write, alu_src, reg_dst, mem_read, mem_write, mem_to_reg, branch,
   reg [1:0] alu_op);
 //Parameters were defined to make the code more understandable
  parameter r_type = 6'b000000, addi = 6'b001000, lw = 6'b100011, sw = 6'b101011, jump = 6'b000010, beq = 6'b000100;
 
   always @(op)
   	begin
       	case(op)
           	r_type:
               	begin
                   	reg_write   <= 1'b1;	// Write to Register
                   	alu_src 	<= 1'b0;	// ALU Src is Read Data 2
                   	reg_dst 	<= 1'b1;	// Destination Reg Comes from Inst[15:11]  
                   	mem_read	<= 1'b0;	// Not Reading from Memory
                   	mem_write   <= 1'b0;	// Not Writing to Memory
                   	mem_to_reg  <= 1'b0;	// Not Reading from Memory
                   	branch  	<= 1'b0;	// Not Branching
                   	alu_op  	<= 2'b10;   // Funct field is used to determine the ALU control signal settings
               	end
 
           	addi:
               	begin
                   	reg_write   <= 1'b1;	// Write to Register
                   	alu_src 	<= 1'b1;	// ALU Src is Immediate Data
                   	reg_dst 	<= 1'b0;	// Destination Reg Comes from Inst[20:16]
                   	mem_read	<= 1'b0;	// Not Reading from Memory
                   	mem_write   <= 1'b0;	// Not Writing to Memory
                   	mem_to_reg  <= 1'b0;	// Not Reading from Memory
                   	branch  	<= 1'b0;	// Not Branching
                   	alu_op  	<= 2'b00;   // ALU Operation Add
               	end
 
           	lw:
               	begin
                   	reg_write   <= 1'b1;	// Write to Register
                   	alu_src 	<= 1'b1;	// ALU Src is Immediate Data
                   	reg_dst 	<= 1'b0;	// Destination Reg Comes from Inst[20:16]  
                   	mem_read	<= 1'b1;	// Reading from Memory
                   	mem_write   <= 1'b0;	// Not Writing to Memory
                   	mem_to_reg  <= 1'b1;	// Reading from Memory
                   	branch  	<= 1'b0;	// Not Branching
                   	alu_op  	<= 2'b00;   // ALU Operation Add
               	end
 
           	sw:
               	begin
                   	reg_write   <= 1'b0;	// Write to Memory, not Register
                   	alu_src 	<= 1'b1;	// ALU Src is Immediate Data
                   	reg_dst 	<= 1'b0;	// Destination Reg Comes from Inst[20:16]  
                   	mem_read	<= 1'b0;	// Not Reading from Memory
                   	mem_write   <= 1'b1;	// Writing to Memory
                   	mem_to_reg  <= 1'b0;	// Not Reading from Memory
                   	branch  	<= 1'b0;	// Not Branching
                   	alu_op  	<= 2'b00;   // ALU Operation Add
               	end
 
           	jump:
               	begin
                   	reg_write   <= 1'b0;	// No write
                   	alu_src 	<= 1'b0;	// ALU Src is Immediate Data
                   	reg_dst 	<= 1'b0;	// Destination Reg Comes from Inst[20:16]  
                   	mem_read	<= 1'b0;	// Not Reading from Memory
                   	mem_write   <= 1'b0;	// Not Writing to Memory
                   	mem_to_reg  <= 1'b0;	// Not Reading from Memory
                   	branch  	<= 1'b1;	// Branching
                   	alu_op  	<= 2'b00;   // ALU Operation Add
               	end
 
           	beq:
               	begin
                   	reg_write   <= 1'b0;	// No write
                   	alu_src 	<= 1'b0;	// ALU Src is Immediate Data
                   	reg_dst 	<= 1'b0;	// Destination Reg Comes from Inst[20:16]  
                   	mem_read	<= 1'b0;	// Not Reading from Memory
                   	mem_write   <= 1'b0;	// Not Writing to Memory
                   	mem_to_reg  <= 1'b0;	// Not Reading from Memory
                   	branch  	<= 1'b1;	// Branching
                   	alu_op  	<= 2'b01;   // ALU Operation Sub
               	end
       	endcase
   	end
endmodule

/*  Below is the testbench for the Instruction Decode Module
	We test the intruction decode unit with the instructions provided to us from the project documentation

*/
`timescale 1ns/10ps
module ID_tb;
 
reg [31:0] inst = 0, w_data;
reg [4:0] write_reg = 0;
 
wire reg_write_out, alu_src, reg_dst, mem_read, mem_write, mem_to_reg, branch;
wire [1:0] alu_op;
wire [31:0] r_data_1, r_data_2, sign_ext_inst;
wire [4:0] rs, rt, rd;
 
localparam period = 10;
 
ID UUT (.inst (inst), .w_data (w_data), .write_reg (write_reg),
    	.reg_write_out (reg_write_out), .alu_src (alu_src), .reg_dst (reg_dst), .mem_read (mem_read), .mem_write (mem_write), .mem_to_reg (mem_to_reg), .branch (branch),
    	.alu_op (alu_op), .r_data_1 (r_data_1), .r_data_2 (r_data_2), .sign_ext_inst (sign_ext_inst));
 
           	 
initial begin
	write_reg = 5'd10;
	w_data = 32'hFFFFFFFF;
    
	inst = 32'h02339022;  // sub  sub $s2, $s1, $s3	HEX: 0x02339022
	#period
	inst = 32'h024D5024;  // and   and $t2, $s2, $t5   HEX: 0x024D5024
	#period
	inst = 32'h020A5025;  // or	or $t2, $s0, $t2	HEX: 0x020A5025
	#period
	inst = 32'h01289820;  // add1  add1 $s3, $t1, $t0  HEX: 0x01289820
	#period
	inst = 32'h8E4B0064;  // lw	lw $t3, 100($s2)	HEX: 0x8E4B0064
	#period
	inst = 32'h217400C8;  // addi  addi $s4, $t3, 200  HEX: 0x217400C8
	#period
	inst = 32'hAD490064;  // sw	sw $t1, 100($t2)	HEX: 0xAD490064
	#period
	inst = 32'h02284827;  // nor   nor $t1, $s1, $t0   HEX: 0x02284827
	#period
	inst = 32'h0252482A;  // slt   slt $t1, $s2, $s2   HEX: 0x0252482A
	#period
	inst = 32'h800009C4;  // j 	j $2500         	HEX: 0x800009C4
   
end
 
endmodule
 
 
 
 
 
 
