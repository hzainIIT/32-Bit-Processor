/* Instruction Fetch Module. 
	Below containts all the modules for the instruction fetch cycle. 
	At the top there is the whole IF module and below we will have all the components that go into it.
	All the way at the bottom of the file will be the testbench for the module. 
*/
module IF(
   input clk, rst, pc_en, sel,
   input [31:0] pc_jump,
   output [31:0] inst, new_pc);
   
   wire [31:0] add_out, pc_in, pc_out;
   
   assign new_pc = add_out;
   
   ProgramCounter PC                	(.clk   	(clk),
                                     	.rst   	(rst),
                                     	.pc_en 	(pc_en),
                                     	.in    	(pc_in),
                                     	.out   	(pc_out));
   
   InstructionMemory IM             	(.in    	(pc_out),
                                     	.out   	(inst));
 
   mux_2_1_32bit MUX                	(.sel    	(sel),
                                     	.a     	(add_out),
                                     	.b     	(pc_jump),
                                     	.out   	(pc_in));
                                    	 
   PC_Adder PCA                     	(.in    	(pc_out),
                                     	.out   	(add_out));
 
endmodule
// Adds four to every instruction, since all instructions are word size
module PC_Adder(
   input   [31:0]  in,
   output reg [31:0] out);
 
   always @(in)
   begin
   	out <= in + 32'h00000004;
   end
 
endmodule
 // Cycles through Program 
module ProgramCounter(
   input clk, rst, pc_en,
   [31:0]  in,
   output reg [31:0] out);
 
   initial begin
   	out <= 32'h00000000;
   end
 
   always @(negedge clk) begin
   	if (rst == 1)
   	begin
       	out <= 32'h00000000;
   	end
   	else
   	begin
       	if (pc_en == 1) begin
           	out <= in;
       	end
   	end
   end
 
endmodule
//Instruction Memory Module which will store all 10 instructions of 32 bti size
module InstructionMemory(
   input   	[31:0]  in,
   output   [31:0]  out);
 
   reg [31:0] memory[0:9];
 
   initial
   	begin
       	memory[0] = 32'h02339022;  // sub   sub $s2, $s1, $s3   HEX: 0x02339022
       	memory[1] = 32'h024D5024;  // and   and $t2, $s2, $t5   HEX: 0x024D5024
       	memory[2] = 32'h020A5025;  // or	or $t2, $s0, $t2	HEX: 0x020A5025
       	memory[3] = 32'h01289820;  // add1  add1 $s3, $t1, $t0  HEX: 0x01289820
       	memory[4] = 32'h8E4B0064;  // lw	lw $t3, 100($s2)	HEX: 0x8E4B0064
       	memory[5] = 32'h217400C8;  // addi  addi $s4, $t3, 200  HEX: 0x217400C8
       	memory[6] = 32'hAD490064;  // sw	sw $t1, 100($t2)	HEX: 0xAD490064
       	memory[7] = 32'h02284827;  // nor   nor $t1, $s1, $t0   HEX: 0x02284827
       	memory[8] = 32'h0252482A;  // slt   slt $t1, $s2, $s2   HEX: 0x0252482A
       	memory[9] = 32'h800009C4;  // j 	j $2500         	HEX: 0x800009C4
   	end
 
   assign out = memory[in>>2];  
 
endmodule
 
module mux_2_1_32bit(
   input sel, [31:0] a, b,
   output reg [31:0] out);
 
	always@(sel or a or b) begin
   	case (sel)
       	1'b0: out <= a;
       	1'b1: out <= b;
   	endcase
	end
   
endmodule
 
/* Below is the testbench file for the Instruction Fetch. 
Which essentially just cycles through program counter reading out different instruction.
*/
module IF_tb;
 
reg clk, rst, sel, pc_en;
reg [31:0] pc_jump;
 
wire [31:0] inst,new_pc,current_pc;
 
localparam period = 10;
 
IF UUT (.clk (clk), .rst (rst), .sel(sel), .pc_en (pc_en),
                      	.pc_jump (pc_jump), .inst(inst), .new_pc (new_pc));
                     	 
initial begin
	clk = 1;
	rst = 0;
	sel = 0;
	pc_en = 1;
	pc_jump = 32'h00000000;
end
 
always #(period/2) clk=~clk;
 
endmodule
 
